一、本地事务
脏读：事务A还未提交，事务B就读取到了事务A待提交的数据（这种级别最低，没有隔离性，解决方法是把级别调整至READ_COMMITTED--未提交读）
不可重复读：事务A读取两次，同时事务B在A两次读取期间update or delete删除了数据，导致两次读取数据不一致。（解决方法是把级别调整为REPEATABLE_READ--可重复读）
幻读：事务A读取两次，同时事务B在两次读取期间insert数据，导致读取数据不正确（解决方法是把级别改为SERIALIZABLE_READ--串行化）
事务的隔离级别：
1、读未提交：read—uncommitted 没有隔离性可言，原子性，一致性更无法保证。
2、读已提交：read-committed   可以在读取过程中防止防止脏读的可能性
3、重复读取：repeatable_read  可以在读取过程中防止update，delete语句执行导致的重复读情况，但无法防止insert（mysql默认级别）
4、串行化：serializable       可以在读取过程中防止insert语句执行导致的幻读，完全是加锁串行化，效率低
InnoDB的事务实现机制：
1、锁机制
    RU:不加锁
    RC:行级共享锁（读到尝试获取锁，并加锁，如果有其余线程持有锁，是不可读的），读完立刻释放锁
    RR：行级共享锁（整个事务期间都持有锁，其余的线程无法对该行进行任何操作），事务结束释放
    SE：表级共享锁，事务结束释放（重锁）
    乐观锁：是应用系统层面和数据的业务逻辑层次上的（实际上并没有加锁，只不过大家一直这样叫而已），利用程序处理并发
    悲观锁： 完全依赖于数据库锁的机制实现的，在数据库中可以使用Repeatable Read的隔离级别（可重复读）来实现悲观锁，它完全满足悲观锁的要求（加锁）
2、MVCC机制
       CAS和读写分离====>>>>>RC和RR级别
------------------------------------------------------------------------------------------------------------------------
二、分布式事务
跨JVM进程or跨数据库节点  无法实现本地事务
1、CAP理论 Consistency 、Availability 、Partition tolerance  一致性、可用性、分区容忍性
C：一致性--主从数据库，主库修改后，从库能立刻读取到最新数据（要将将从数据库资源锁定，同步完成释放锁定）
A：可用性--任何事务操作都能得到响应结果，且不会出现超时或响应错误（不可将从数据库资源锁定）
P：网络分区通信失败，要有容错。或者节点挂掉，也可用
组合方式
（1）、AP（最常见的）
（2）、CP
（3）、CA
2、BASE理论： CAP强调强一致性，BASE强调最终一致性
Basic Available （基本可用）,出现故障核心服务必须可用。满足BASE的事务为”柔性事务“。（1、基本可用，2、软状态，3、最终一致）
3、2PC（两阶段提交协议） P--prepare phase准备阶段，C--commit phase提交阶段
关系型数据库mysql、oracle本身就是一个分布式事务(2pc模式)
（1）、准备阶段 RM执行操作，资源锁定
（2）、提交阶段 TM接受RM在准备阶段的执行回复，全部成功，通知RM提交事务释放资源锁，有一个失败通知所有RM回滚
（3）、解决方案：
    i:XA方案 基于数据库的2PC协议实现分布式事务
            DTP模型定义TM（事务管理器）、RM（资源管理器）之间通讯的接口规范叫XA，简单理解为数据库提供的2PC接口协议。
            基于数据库的XA规范来实现2PC成为XA方案。
            缺点：资源锁需要两个过程结束才释放锁，性能不好。且必须要求数据库支持2PC协议
    ii:Seata方案：
            阿里中间件Fescar后更名为Seata。业务无侵入，多个分支事务的全局事务。
            优点：无需数据库支持2PC。占用资源时间短。是应用，对业务0倾入。
            额外增加了个Transaction Coordinator(TC)事务协调器，是个独立中间件，需要独立部署运行
            准备阶段就提交本地事务，可以省去持有锁的时间
            如果最终全部成功，则删除全部分支事务的un_do_log
            如果最终失败，则根据的undo_log的回滚语句进行回滚
            使用：1-全局事务开始@GlobalTransactional
                 2-每个本地事务仍然使用@Transactional
                 3-每个数据库都要建一个undo_log表，此表是保证本地事务一致性的关键
4、TCC（try、confirm、cancel）